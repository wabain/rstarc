[tests]
enabled = ["tokens", "pretty", "ir"]

[tokens]
returncode = "0"
stdout = """
0..7 Modulus
8..13 takes
14..20 Number
21..24 and
25..32 Divisor
32..33 ⏎
33..38 while
39..45 Number
46..48 is
49..51 as
52..56 great
57..59 as
60..67 Divisor
67..68 ⏎
68..71 put
72..78 Number
79..84 minus
85..92 Divisor
93..97 into
98..104 Number
104..105 ⏎
105..106 ⏎
106..110 give
111..115 back
116..122 Number
122..123 ⏎
123..124 ⏎
124..129 Limit
130..132 is
133..138 "100"
138..139 ⏎
139..146 Counter
147..149 is
150..153 "0"
153..154 ⏎
154..158 Fizz
159..161 is
162..165 "3"
165..166 ⏎
166..170 Buzz
171..173 is
174..177 "5"
177..178 ⏎
178..183 until
184..191 Counter
192..194 is
195..200 Limit
200..201 ⏎
201..206 build
207..214 Counter
215..217 up
217..218 ⏎
218..220 if
221..228 Modulus
229..235 taking
236..243 Counter
243..244 ,
245..249 Fizz
250..252 is
253..256 "0"
257..260 and
261..268 Modulus
269..275 taking
276..283 Counter
283..284 ,
285..289 Buzz
290..292 is
293..296 "0"
296..297 ⏎
297..300 say
301..312 "FizzBuzz!"
312..313 ⏎
313..321 continue
321..322 ⏎
322..323 ⏎
323..325 if
326..333 Modulus
334..340 taking
341..348 Counter
348..349 ,
350..354 Fizz
355..357 is
358..361 "0"
361..362 ⏎
362..365 say
366..373 "Fizz!"
373..374 ⏎
374..382 continue
382..383 ⏎
383..384 ⏎
384..386 if
387..394 Modulus
395..401 taking
402..409 Counter
409..410 ,
411..415 Buzz
416..418 is
419..422 "0"
422..423 ⏎
423..426 say
427..434 "Buzz!"
434..435 ⏎
435..443 continue
443..444 ⏎
444..445 ⏎
445..448 say
449..456 Counter
456..457 ⏎
457..458 ⏎
458..458 <eof>
"""

[pretty]
returncode = "0"
stdout = """
Modulus takes Number and Divisor
While Number is as great as Divisor
Put Number minus Divisor into Number

Give back Number

Put "100" into Limit
Put "0" into Counter
Put "3" into Fizz
Put "5" into Buzz
Until Counter is Limit
Build Counter up
If Modulus taking Counter, Fizz is "0" and Modulus taking Counter, Buzz is "0"
Say "FizzBuzz!"
Continue

If Modulus taking Counter, Fizz is "0"
Say "Fizz!"
Continue

If Modulus taking Counter, Buzz is "0"
Say "Buzz!"
Continue

Say Counter

"""

[ir]
returncode = "0"
stdout = """
main:
  Buzz := store mysterious
  Counter := store mysterious
  Fizz := store mysterious
  Limit := store mysterious
  Modulus := store mysterious
  Modulus := store Function(1)
  Limit := store "100"
  Counter := store "0"
  Fizz := store "3"
  Buzz := store "5"
  jump .loop_check0
.loop_check0:
  t0 := is Counter, Limit
  jumpif t0, .loop_end2, .loop_start1
.loop_start1:
  Counter := in-place incr 1
  t1 := call Modulus, [Counter, Fizz]
  dynamic_t0 := is t1, "0"
  jumpif dynamic_t0, .and5, .and_else6
.and5:
  t2 := call Modulus, [Counter, Buzz]
  dynamic_t0 := is t2, "0"
  jump .and_else6
.and_else6:
  jumpif dynamic_t0, .then3, .else4
.then3:
  say "FizzBuzz!"
  jump .loop_check0
.else4:
  t3 := call Modulus, [Counter, Fizz]
  t4 := is t3, "0"
  jumpif t4, .then7, .else8
.then7:
  say "Fizz!"
  jump .loop_check0
.else8:
  t5 := call Modulus, [Counter, Buzz]
  t6 := is t5, "0"
  jumpif t6, .then9, .else10
.then9:
  say "Buzz!"
  jump .loop_check0
.else10:
  say Counter
  jump .loop_check0
.loop_end2:
  return-default

;
; Function Modulus takes Number, Divisor
; Scope is 1
;
f1_Modulus:
  Divisor := load-arg 1
  Number := load-arg 0
  jump .loop_check0
.loop_check0:
  t0 := ge Number, Divisor
  jumpif t0, .loop_start1, .loop_end2
.loop_start1:
  Number := sub Number, Divisor
  jump .loop_check0
.loop_end2:
  return Number
"""
