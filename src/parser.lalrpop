use lexer;
use ast;

grammar;

pub Program: Vec<ast::Statement> = {
    "\n"* <t:(TermStatement "\n"*)*> EOF =>
        t.into_iter().map(|(s, _)| s).collect::<Vec<_>>(),
}

TermStatement: ast::Statement = {
    <start:@L> <s:Statement> <end:@R> "\n" =>
        ast::Statement { kind: s, pos: ast::Pos(start, end) },
}

Statement: ast::StatementKind = {
    "Put" <e:Expr> "Into" <v:LValue> => ast::StatementKind::Assign(v, e),

    // The spec talks about "Literal Words" being allowed here without defining
    // the term, but its examples show numeric literals being allowed, so I'm
    // taking it to mean any literal
    <v:LValue> "Is" <e:Literal> => ast::StatementKind::Assign(v, e),
    <v:LValue> "Was" <e:Literal> => ast::StatementKind::Assign(v, e),

    "Build" <v:LValue> <count:IncrCount> => ast::StatementKind::Incr(v, count),
    "Knock" <v:LValue> <count:DecrCount> => ast::StatementKind::Decr(v, count),
    "Say" <e:Expr> => ast::StatementKind::Say(e),

    "Continue" => ast::StatementKind::Continue,
    "Break" => ast::StatementKind::Break,
    "Give" "Back" <e:Expr> => ast::StatementKind::Return(e),

    "If" <c:Expr> "\n" <b:Block> <els:("Else" "\n" Block)?> => {
        let else_block = els.map_or_else(|| Vec::new(), |(_, _, b2)| b2);
        ast::StatementKind::Condition(c, b, else_block)
    },

    "While" <c:Expr> "\n" <b:Block> => ast::StatementKind::While(c, b),
    "Until" <c:Expr> "\n" <b:Block> => ast::StatementKind::Until(c, b),
    <v:Variable> "Takes" <a:FuncDecArgs> "\n" <b:Block> =>
        ast::StatementKind::FuncDef(v, a, b),
}

IncrCount: u32 = {
    "Up" => 1,
    "Up" "," <c:IncrCount> => c + 1,
    "Up" <c:IncrCount> => c + 1,
}

DecrCount: u32 = {
    "Down" => 1,
    "Down" "," <c:DecrCount> => c + 1,
    "Down" <c:DecrCount> => c + 1,
}

FuncDecArgs: Vec<ast::Variable> = {
    <v:(Variable FuncDecSep)*> <e:Variable?> => {
        let mut vars: Vec<_> = v.into_iter().map(|(var, _)| var).collect();
        if let Some(e) = e {
            vars.push(e);
        }
        vars
    }
}

FuncDecSep: () = {
    "And" => (),
    "," => (),
}

Block: Vec<ast::Statement> = {
    <b:TermStatement*> => b
}

// Function calls are not allowed before "and" comparisons to prevent ambiguity
Expr: ast::Expr = {
    <e1:PreConjunctionComparisonExpr> "And" <e2:Expr> =>
        ast::Expr::logical(ast::Logical::And(e1, e2)),
    <e1:ComparisonExpr> "Or" <e2:Expr> =>
        ast::Expr::logical(ast::Logical::Or(e1, e2)),
    <e1:ComparisonExpr> "Nor" <e2:Expr> =>
        ast::Expr::logical(ast::Logical::Nor(e1, e2)),
    ComparisonExpr => <>,
}

ComparisonExpr: ast::Expr = {
    <a:AddExpr> <cmp:Comparator> <b:ComparisonExpr> =>
        ast::Expr::compare(ast::Comparison(a, cmp, b)),
    AddExpr => <>,
}

PreConjunctionComparisonExpr: ast::Expr = {
    <a:AddExpr> <cmp:Comparator> <b:PreConjunctionComparisonExpr> =>
        ast::Expr::compare(ast::Comparison(a, cmp, b)),
    PreConjunctionAddExpr => <>,
}

Comparator: ast::Comparator = {
    "Is" => ast::Comparator::Is,
    "Isn't" => ast::Comparator::IsNot,
    "Is" "Greater" "Than" => ast::Comparator::IsGreaterThan,
    "Is" "Less" "Than" => ast::Comparator::IsLessThan,
    "Is" "As" "Great" "As" => ast::Comparator::IsAsGreatAs,
    "Is" "As" "Little" "As" => ast::Comparator::IsAsLittleAs,
}

AddExpr: ast::Expr = {
    MultExpr => <>,
    <e1:MultExpr> "Plus" <e2:AddExpr> => ast::Expr::Add(Box::new(e1), Box::new(e2)),
    <e1:MultExpr> "Minus" <e2:AddExpr> => ast::Expr::Sub(Box::new(e1), Box::new(e2)),
}

PreConjunctionAddExpr: ast::Expr = {
    PreConjunctionMultExpr => <>,
    <e1:MultExpr> "Plus" <e2:PreConjunctionAddExpr> => ast::Expr::Add(Box::new(e1), Box::new(e2)),
    <e1:MultExpr> "Minus" <e2:PreConjunctionAddExpr> => ast::Expr::Sub(Box::new(e1), Box::new(e2)),
}

MultExpr: ast::Expr = {
    NotExpr => <>,
    <e1:NotExpr> "Times" <e2:MultExpr> => ast::Expr::Mul(Box::new(e1), Box::new(e2)),
    <e1:NotExpr> "Over" <e2:MultExpr> => ast::Expr::Div(Box::new(e1), Box::new(e2)),
}

PreConjunctionMultExpr: ast::Expr = {
    PreConjunctionNotExpr => <>,
    <e1:NotExpr> "Times" <e2:PreConjunctionMultExpr> => ast::Expr::Mul(Box::new(e1), Box::new(e2)),
    <e1:NotExpr> "Over" <e2:PreConjunctionMultExpr> => ast::Expr::Div(Box::new(e1), Box::new(e2)),
}

NotExpr: ast::Expr = {
    "Not" <e:FuncCallExpr> => ast::Expr::logical(ast::Logical::Not(e)),
    FuncCallExpr => <>,
}

PreConjunctionNotExpr: ast::Expr = {
    "Not" <e:SimpleExpr> => ast::Expr::logical(ast::Logical::Not(e)),
    SimpleExpr => <>,
}

FuncCallExpr: ast::Expr = {
    <f:SimpleExpr> "Taking" <a:(SimpleExpr FuncArgSep)*> <an:SimpleExpr> => {
        let mut args: Vec<_> = a.into_iter().map(|(e, _)| Box::new(e)).collect();
        args.push(Box::new(an));
        ast::Expr::FuncCall(Box::new(f), args)
    },
    SimpleExpr => <>,
}

FuncArgSep: () = {
    "," => (),
    "And" => (),
}

SimpleExpr: ast::Expr = {
    LValue => ast::Expr::LValue(<>),
    Literal => <>,
}

Literal: ast::Expr = {
    TStringLiteral => ast::Expr::Literal(<>),
    TBooleanLiteral => ast::Expr::Literal(<>),
    TNumberLiteral => ast::Expr::Literal(<>),
    TMysteriousLiteral => ast::Expr::Literal(<>),
    TNullLiteral => ast::Expr::Literal(<>),
}

LValue: ast::LValue = {
    Variable => ast::LValue::Variable(<>),
    TPronoun => ast::LValue::Pronoun(<>),
}

Variable: ast::Variable = {
    <start:@L> <v:TProperVar> <end:@R> =>
        ast::Variable::ProperVar(v, ast::Pos(start, end)),
    <start:@L> <p:TCommonPrep> <v:TCommonVar> <end:@R> =>
        ast::Variable::CommonVar(p, v, ast::Pos(start, end)),
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token {
        // Variables and friends
        TProperVar => lexer::Token::ProperVar(_),
        TCommonVar => lexer::Token::CommonVar(_),
        TPronoun => lexer::Token::Pronoun(_),
        TCommonPrep => lexer::Token::CommonPrep(_),

        // Types
        TStringLiteral => lexer::Token::StringLiteral(_),
        TBooleanLiteral => lexer::Token::BooleanLiteral(_),
        TNumberLiteral => lexer::Token::NumberLiteral(_),
        TMysteriousLiteral => lexer::Token::MysteriousLiteral,
        TNullLiteral => lexer::Token::NullLiteral,

        // Punctuation
        "\n" => lexer::Token::Newline,
        "," => lexer::Token::Comma,

        // Other keywords
        "Is" => lexer::Token::Is,
        "Was" => lexer::Token::Was,
        "Not" => lexer::Token::Not,
        "Isn't" => lexer::Token::Isnt,
        "Than" => lexer::Token::Than,
        "As" => lexer::Token::As,
        "Greater" => lexer::Token::Greater,
        "Less" => lexer::Token::Less,
        "Great" => lexer::Token::Great,
        "Little" => lexer::Token::Little,
        "Put" => lexer::Token::Put,
        "Into" => lexer::Token::Into,
        "Build" => lexer::Token::Build,
        "Up" => lexer::Token::Up,
        "Knock" => lexer::Token::Knock,
        "Down" => lexer::Token::Down,
        "Plus" => lexer::Token::Plus,
        "Minus" => lexer::Token::Minus,
        "Times" => lexer::Token::Times,
        "Over" => lexer::Token::Over,
        "Listen" => lexer::Token::Listen,
        "To" => lexer::Token::To,
        "Say" => lexer::Token::Say,
        "If" => lexer::Token::If,
        "Else" => lexer::Token::Else,
        "While" => lexer::Token::While,
        "Until" => lexer::Token::Until,
        "Continue" => lexer::Token::Continue,
        "Break" => lexer::Token::Break,
        "Takes" => lexer::Token::Takes,
        "Taking" => lexer::Token::Taking,
        "Take" => lexer::Token::Take,
        "From" => lexer::Token::From,
        "Give" => lexer::Token::Give,
        "Back" => lexer::Token::Back,
        "And" => lexer::Token::And,
        "Or" => lexer::Token::Or,
        "Nor" => lexer::Token::Nor,

        EOF => lexer::Token::EOF,
    }
}
