use lexer;
use ast;

grammar;

pub Program: Vec<ast::Statement> = {
    "\n"* <t:(TermStatement "\n"*)*> EOF =>
        t.into_iter().map(|(s, _)| s).collect::<Vec<_>>(),
}

TermStatement: ast::Statement = {
    <start:@L> <s:Statement> <end:@R> "\n" =>
        ast::Statement { kind: s, pos: ast::Pos(start, end) },
}

Statement: ast::StatementKind = {
    "Put" <e:Expr> "Into" <v:LValue> => ast::StatementKind::Assign(v, e),

    // FIXME: Spec is unclear on what literals are allowed here. All of them?
    <v:LValue> "Is" <e:Literal> => ast::StatementKind::Assign(v, e),
    <v:LValue> "Was" <e:Literal> => ast::StatementKind::Assign(v, e),

    "Build" <v:LValue> "Up" => ast::StatementKind::Incr(v),
    "Knock" <v:LValue> "Down" => ast::StatementKind::Decr(v),
    "Say" <e:Expr> => ast::StatementKind::Say(e),

    "Continue" => ast::StatementKind::Continue,
    "Break" => ast::StatementKind::Break,
    "Give" "Back" <e:Expr> => ast::StatementKind::Return(e),

    "If" <c:Conditional> "\n" <b:Block> <els:("Else" "\n" Block)?> => {
        let else_block = els.map_or_else(|| Vec::new(), |(_, _, b2)| b2);
        ast::StatementKind::Condition(c, b, else_block)
    },

    "While" <c:Conditional> "\n" <b:Block> => ast::StatementKind::While(c, b),
    "Until" <c:Conditional> "\n" <b:Block> => ast::StatementKind::Until(c, b),
    <v:Variable> "Takes" <a:FuncDecArgs> "\n" <b:Block> =>
        ast::StatementKind::FuncDef(v, a, b),
}

FuncDecArgs: Vec<ast::Variable> = {
    <v:(Variable FuncDecSep)*> <e:Variable?> => {
        let mut vars: Vec<_> = v.into_iter().map(|(var, _)| var).collect();
        if let Some(e) = e {
            vars.push(e);
        }
        vars
    }
}

FuncDecSep: () = {
    "And" => (),
    "," => (),
}

Block: Vec<ast::Statement> = {
    <b:TermStatement*> => b
}

Expr: ast::Expr = {
    Comparison => ast::Expr::Compare(Box::new(<>)),
    FuncCallExpr => <>,
}

FuncCallExpr: ast::Expr = {
    <f:SimpleExpr> "Taking" <a:(MultExpr ",")*> <an:MultExpr> => {
        let mut args: Vec<_> = a.into_iter().map(|(e, _)| Box::new(e)).collect();
        args.push(Box::new(an));
        ast::Expr::FuncCall(Box::new(f), args)
    },
    AddExpr => <>,
}

AddExpr: ast::Expr = {
    MultExpr => <>,
    <e1:MultExpr> "Plus" <e2:AddExpr> => ast::Expr::Add(Box::new(e1), Box::new(e2)),
    <e1:MultExpr> "Minus" <e2:AddExpr> => ast::Expr::Sub(Box::new(e1), Box::new(e2)),
}

MultExpr: ast::Expr = {
    SimpleExpr => <>,
    <e1:SimpleExpr> "Times" <e2:MultExpr> => ast::Expr::Mul(Box::new(e1), Box::new(e2)),
    <e1:SimpleExpr> "Over" <e2:MultExpr> => ast::Expr::Div(Box::new(e1), Box::new(e2)),
}

// FIXME: Precedence?
Conditional: ast::Conditional = {
    Comparison => ast::Conditional::Comparison(<>),
    <e1:Comparison> "And" <e2:Conditional> =>
        ast::Conditional::And(Box::new(ast::Conditional::Comparison(e1)), Box::new(e2)),
    <e1:Comparison> "Or" <e2:Conditional> =>
        ast::Conditional::Or(Box::new(ast::Conditional::Comparison(e1)), Box::new(e2)),
}

Comparison: ast::Comparison = {
    <a:FuncCallExpr> "Is" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::Is, b),
    <a:FuncCallExpr> "Is" "Not" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsNot, b),
    <a:FuncCallExpr> "Ain't" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsNot, b),
    <a:FuncCallExpr> "Is" "Greater" "Than" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsGreaterThan, b),
    <a:FuncCallExpr> "Is" "Less" "Than" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsLessThan, b),
    <a:FuncCallExpr> "Is" "As" "Great" "As" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsAsGreatAs, b),
    <a:FuncCallExpr> "Is" "As" "Little" "As" <b:Expr> =>
        ast::Comparison(a, ast::Comparator::IsAsLittleAs, b),
}

SimpleExpr: ast::Expr = {
    LValue => ast::Expr::LValue(<>),
    Literal => <>,
}

Literal: ast::Expr = {
    TStringLiteral => ast::Expr::Literal(<>),
    TBooleanLiteral => ast::Expr::Literal(<>),
    TNumberLiteral => ast::Expr::Literal(<>),
    TMysteriousLiteral => ast::Expr::Literal(<>),
    TNullLiteral => ast::Expr::Literal(<>),
}

LValue: ast::LValue = {
    Variable => ast::LValue::Variable(<>),
    TPronoun => ast::LValue::Pronoun(<>),
}

Variable: ast::Variable = {
    TProperVar => ast::Variable::ProperVar(<>),
    TCommonPrep TCommonVar => ast::Variable::CommonVar(<>),
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token {
        // Variables and friends
        TProperVar => lexer::Token::ProperVar(_),
        TCommonVar => lexer::Token::CommonVar(_),
        TPronoun => lexer::Token::Pronoun(_),
        TCommonPrep => lexer::Token::CommonPrep(_),

        // Types
        TStringLiteral => lexer::Token::StringLiteral(_),
        TBooleanLiteral => lexer::Token::BooleanLiteral(_),
        TNumberLiteral => lexer::Token::NumberLiteral(_),
        TMysteriousLiteral => lexer::Token::MysteriousLiteral,
        TNullLiteral => lexer::Token::NullLiteral,

        // Punctuation
        "\n" => lexer::Token::Newline,
        "," => lexer::Token::Comma,

        // Other keywords
        "Is" => lexer::Token::Is,
        "Was" => lexer::Token::Was,
        "Not" => lexer::Token::Not,
        "Ain't" => lexer::Token::Aint,
        "Than" => lexer::Token::Than,
        "As" => lexer::Token::As,
        "Greater" => lexer::Token::Greater,
        "Less" => lexer::Token::Less,
        "Great" => lexer::Token::Great,
        "Little" => lexer::Token::Little,
        "Put" => lexer::Token::Put,
        "Into" => lexer::Token::Into,
        "Build" => lexer::Token::Build,
        "Up" => lexer::Token::Up,
        "Knock" => lexer::Token::Knock,
        "Down" => lexer::Token::Down,
        "Plus" => lexer::Token::Plus,
        "Minus" => lexer::Token::Minus,
        "Times" => lexer::Token::Times,
        "Over" => lexer::Token::Over,
        "Listen" => lexer::Token::Listen,
        "To" => lexer::Token::To,
        "Say" => lexer::Token::Say,
        "If" => lexer::Token::If,
        "Else" => lexer::Token::Else,
        "While" => lexer::Token::While,
        "Until" => lexer::Token::Until,
        "Continue" => lexer::Token::Continue,
        "Break" => lexer::Token::Break,
        "Takes" => lexer::Token::Takes,
        "Taking" => lexer::Token::Taking,
        "Take" => lexer::Token::Take,
        "From" => lexer::Token::From,
        "Give" => lexer::Token::Give,
        "Back" => lexer::Token::Back,
        "And" => lexer::Token::And,
        "Or" => lexer::Token::Or,

        EOF => lexer::Token::EOF,
    }
}
